# Diffractsim Util

[_Documentation generated by Documatic_](https://www.documatic.com)

<!---Documatic-section-Codebase Structure-start--->
## Codebase Structure

<!---Documatic-block-system_architecture-start--->
```mermaid
None
```
<!---Documatic-block-system_architecture-end--->

# #
<!---Documatic-section-Codebase Structure-end--->

<!---Documatic-section-diffractsim.util.scaled_FT.scaled_fourier_transform-start--->
## [diffractsim.util.scaled_FT.scaled_fourier_transform](8-diffractsim_util.md#diffractsim.util.scaled_FT.scaled_fourier_transform)

<!---Documatic-section-scaled_fourier_transform-start--->
<!---Documatic-block-diffractsim.util.scaled_FT.scaled_fourier_transform-start--->
<details>
	<summary><code>diffractsim.util.scaled_FT.scaled_fourier_transform</code> code snippet</summary>

```python
def scaled_fourier_transform(x, y, U, λ=1, z=1, scale_factor=1, mesh=False):
    global bd
    from .backend_functions import backend as bd
    (Ny, Nx) = U.shape
    if mesh == False:
        dx = x[1] - x[0]
        dy = y[1] - y[0]
        (xx, yy) = bd.meshgrid(x, y)
    else:
        dx = x[0, 1] - x[0, 0]
        dy = y[1, 0] - y[0, 0]
        (xx, yy) = (x, y)
    extent_x = dx * Nx
    extent_y = dy * Ny
    L1 = extent_x
    L2 = extent_x * scale_factor
    f_factor = 1 / (λ * z)
    fft_U = bd.fft.fftshift(bd.fft.fft2(U * bd.exp(-1j * bd.pi * f_factor * (xx ** 2 + yy ** 2)) * bd.exp(1j * bd.pi * (L1 - L2) / L1 * f_factor * (xx ** 2 + yy ** 2))))
    fx = bd.fft.fftshift(bd.fft.fftfreq(Nx, d=dx))
    fy = bd.fft.fftshift(bd.fft.fftfreq(Ny, d=dy))
    (fxx, fyy) = bd.meshgrid(fx, fy)
    Uf = bd.fft.ifft2(bd.fft.ifftshift(bd.exp(-1j * bd.pi / f_factor * L1 / L2 * (fxx ** 2 + fyy ** 2)) * fft_U))
    extent_x = extent_x * scale_factor
    extent_y = extent_y * scale_factor
    dx = dx * scale_factor
    dy = dy * scale_factor
    x = x * scale_factor
    y = y * scale_factor
    xx = xx * scale_factor
    yy = yy * scale_factor
    Uf = L1 / L2 * bd.exp(-1j * bd.pi * f_factor * (xx ** 2 + yy ** 2) - 1j * bd.pi * f_factor * (L1 - L2) / L2 * (xx ** 2 + yy ** 2)) * Uf * 1j * (λ * z)
    if mesh == False:
        return (x, y, Uf)
    else:
        return (xx, yy, Uf)
```
</details>
<!---Documatic-block-diffractsim.util.scaled_FT.scaled_fourier_transform-end--->
<!---Documatic-section-scaled_fourier_transform-end--->

# #
<!---Documatic-section-diffractsim.util.scaled_FT.scaled_fourier_transform-end--->

<!---Documatic-section-diffractsim.util.bluestein_FFT.bluestein_fft2-start--->
## [diffractsim.util.bluestein_FFT.bluestein_fft2](8-diffractsim_util.md#diffractsim.util.bluestein_FFT.bluestein_fft2)

<!---Documatic-section-bluestein_fft2-start--->
```mermaid
flowchart LR
diffractsim.util.bluestein_FFT.bluestein_fft2-->diffractsim.util.bluestein_FFT.bluestein_fft
diffractsim.util.bluestein_FFT.bluestein_fft-->diffractsim.util.chirp_z_transform.chirpz
```

### Object Calls

* [diffractsim.util.bluestein_FFT.bluestein_fft](8-diffractsim_util.md#diffractsim.util.bluestein_FFT.bluestein_fft)

<!---Documatic-block-diffractsim.util.bluestein_FFT.bluestein_fft2-start--->
<details>
	<summary><code>diffractsim.util.bluestein_FFT.bluestein_fft2</code> code snippet</summary>

```python
def bluestein_fft2(U, fx0, fx1, fxs, fy0, fy1, fys):
    (Ny, Nx) = U.shape
    return bluestein_fft(bluestein_fft(U, f0=fy0, f1=fy1, fs=fys, M=Ny, axis=0), f0=fx0, f1=fx1, fs=fxs, M=Nx, axis=1)
```
</details>
<!---Documatic-block-diffractsim.util.bluestein_FFT.bluestein_fft2-end--->
<!---Documatic-section-bluestein_fft2-end--->

# #
<!---Documatic-section-diffractsim.util.bluestein_FFT.bluestein_fft2-end--->

<!---Documatic-section-diffractsim.util.bluestein_FFT.bluestein_fftfreq-start--->
## [diffractsim.util.bluestein_FFT.bluestein_fftfreq](8-diffractsim_util.md#diffractsim.util.bluestein_FFT.bluestein_fftfreq)

<!---Documatic-section-bluestein_fftfreq-start--->
<!---Documatic-block-diffractsim.util.bluestein_FFT.bluestein_fftfreq-start--->
<details>
	<summary><code>diffractsim.util.bluestein_FFT.bluestein_fftfreq</code> code snippet</summary>

```python
def bluestein_fftfreq(f0, f1, M):
    global bd
    from .backend_functions import backend as bd
    df = (f1 - f0) / (M - 1)
    return bd.arange(M) * df + f0
```
</details>
<!---Documatic-block-diffractsim.util.bluestein_FFT.bluestein_fftfreq-end--->
<!---Documatic-section-bluestein_fftfreq-end--->

# #
<!---Documatic-section-diffractsim.util.bluestein_FFT.bluestein_fftfreq-end--->

<!---Documatic-section-diffractsim.util.image_handling.rescale_img_to_custom_coordinates-start--->
## [diffractsim.util.image_handling.rescale_img_to_custom_coordinates](8-diffractsim_util.md#diffractsim.util.image_handling.rescale_img_to_custom_coordinates)

<!---Documatic-section-rescale_img_to_custom_coordinates-start--->
<!---Documatic-block-diffractsim.util.image_handling.rescale_img_to_custom_coordinates-start--->
<details>
	<summary><code>diffractsim.util.image_handling.rescale_img_to_custom_coordinates</code> code snippet</summary>

```python
def rescale_img_to_custom_coordinates(img, image_size, extent_x, extent_y, Nx, Ny):
    (img_pixels_width, img_pixels_height) = img.size
    if image_size != None:
        (new_img_pixels_width, new_img_pixels_height) = (int(np.round(image_size[0] / extent_x * Nx)), int(np.round(image_size[1] / extent_y * Ny)))
    else:
        (new_img_pixels_width, new_img_pixels_height) = (Nx, Ny)
    img = img.resize((new_img_pixels_width, new_img_pixels_height))
    dst_img = Image.new('RGB', (Nx, Ny), 'black')
    (dst_img_pixels_width, dst_img_pixels_height) = dst_img.size
    (Ox, Oy) = ((dst_img_pixels_width - new_img_pixels_width) // 2, (dst_img_pixels_height - new_img_pixels_height) // 2)
    dst_img.paste(img, box=(Ox, Oy))
    return dst_img
```
</details>
<!---Documatic-block-diffractsim.util.image_handling.rescale_img_to_custom_coordinates-end--->
<!---Documatic-section-rescale_img_to_custom_coordinates-end--->

# #
<!---Documatic-section-diffractsim.util.image_handling.rescale_img_to_custom_coordinates-end--->

<!---Documatic-section-diffractsim.util.file_handling.load_graymap_image_as_array-start--->
## [diffractsim.util.file_handling.load_graymap_image_as_array](8-diffractsim_util.md#diffractsim.util.file_handling.load_graymap_image_as_array)

<!---Documatic-section-load_graymap_image_as_array-start--->
<!---Documatic-block-diffractsim.util.file_handling.load_graymap_image_as_array-start--->
<details>
	<summary><code>diffractsim.util.file_handling.load_graymap_image_as_array</code> code snippet</summary>

```python
def load_graymap_image_as_array(string, new_size=None):
    from PIL import Image
    img = Image.open(Path(string))
    img = img.convert('RGB')
    if new_size != None:
        img = img.resize(new_size)
    imgRGB = np.asarray(img) / 255.0
    imgR = imgRGB[:, :, 0]
    imgG = imgRGB[:, :, 1]
    imgB = imgRGB[:, :, 2]
    t = np.array(0.299 * imgR + 0.587 * imgG + 0.114 * imgB)
    t = np.flip(t, axis=0)
    return t
```
</details>
<!---Documatic-block-diffractsim.util.file_handling.load_graymap_image_as_array-end--->
<!---Documatic-section-load_graymap_image_as_array-end--->

# #
<!---Documatic-section-diffractsim.util.file_handling.load_graymap_image_as_array-end--->

<!---Documatic-section-diffractsim.util.file_handling.save_phase_mask_as_image-start--->
## [diffractsim.util.file_handling.save_phase_mask_as_image](8-diffractsim_util.md#diffractsim.util.file_handling.save_phase_mask_as_image)

<!---Documatic-section-save_phase_mask_as_image-start--->
<!---Documatic-block-diffractsim.util.file_handling.save_phase_mask_as_image-start--->
<details>
	<summary><code>diffractsim.util.file_handling.save_phase_mask_as_image</code> code snippet</summary>

```python
def save_phase_mask_as_image(string, phase_mask, phase_mask_format='hsv'):
    if phase_mask_format == 'hsv':
        from matplotlib.colors import hsv_to_rgb
        h = (np.flip(phase_mask, axis=0) + np.pi) / (2 * np.pi)
        s = np.ones_like(h)
        v = np.ones_like(h)
        rgb = hsv_to_rgb(np.moveaxis(np.array([h, s, v]), 0, -1))
        img_RGB = [Image.fromarray(np.round(255 * rgb[:, :, 0]).astype(np.uint8), 'L'), Image.fromarray(np.round(255 * rgb[:, :, 1]).astype(np.uint8), 'L'), Image.fromarray(np.round(255 * rgb[:, :, 2]).astype(np.uint8), 'L')]
        img = Image.merge('RGB', img_RGB)
        img.save(Path(string))
    else:
        h = (np.flip(phase_mask, axis=0) + np.pi) / (2 * np.pi)
        img = Image.fromarray(np.uint8(h * 255), 'L')
        img.save(Path(string))
```
</details>
<!---Documatic-block-diffractsim.util.file_handling.save_phase_mask_as_image-end--->
<!---Documatic-section-save_phase_mask_as_image-end--->

# #
<!---Documatic-section-diffractsim.util.file_handling.save_phase_mask_as_image-end--->

<!---Documatic-section-diffractsim.util.backend_functions.get_backend-start--->
## [diffractsim.util.backend_functions.get_backend](8-diffractsim_util.md#diffractsim.util.backend_functions.get_backend)

<!---Documatic-section-get_backend-start--->
<!---Documatic-block-diffractsim.util.backend_functions.get_backend-start--->
<details>
	<summary><code>diffractsim.util.backend_functions.get_backend</code> code snippet</summary>

```python
def get_backend():
    global backend
    print(backend)
```
</details>
<!---Documatic-block-diffractsim.util.backend_functions.get_backend-end--->
<!---Documatic-section-get_backend-end--->

# #
<!---Documatic-section-diffractsim.util.backend_functions.get_backend-end--->

<!---Documatic-section-diffractsim.util.backend_functions.set_backend-start--->
## [diffractsim.util.backend_functions.set_backend](8-diffractsim_util.md#diffractsim.util.backend_functions.set_backend)

<!---Documatic-section-set_backend-start--->
<!---Documatic-block-diffractsim.util.backend_functions.set_backend-start--->
<details>
	<summary><code>diffractsim.util.backend_functions.set_backend</code> code snippet</summary>

```python
def set_backend(name: str):
    if name == 'CUDA' and (not CUPY_CUDA_AVAILABLE):
        raise RuntimeError('Cupy CUDA backend is not available.\nDo you have a GPU on your computer?\nIs Cupy with CUDA support installed?')
    global backend
    if name == 'CPU':
        backend = numpy
    elif name == 'CUDA':
        backend = cupy
    else:
        raise RuntimeError(f'unknown backend "{name}"')
```
</details>
<!---Documatic-block-diffractsim.util.backend_functions.set_backend-end--->
<!---Documatic-section-set_backend-end--->

# #
<!---Documatic-section-diffractsim.util.backend_functions.set_backend-end--->

<!---Documatic-section-diffractsim.util.image_handling.convert_graymap_image_to_hsvmap_image-start--->
## [diffractsim.util.image_handling.convert_graymap_image_to_hsvmap_image](8-diffractsim_util.md#diffractsim.util.image_handling.convert_graymap_image_to_hsvmap_image)

<!---Documatic-section-convert_graymap_image_to_hsvmap_image-start--->
<!---Documatic-block-diffractsim.util.image_handling.convert_graymap_image_to_hsvmap_image-start--->
<details>
	<summary><code>diffractsim.util.image_handling.convert_graymap_image_to_hsvmap_image</code> code snippet</summary>

```python
def convert_graymap_image_to_hsvmap_image(img):
    imgRGB = np.asarray(img) / 255.0
    imgR = imgRGB[:, :, 0]
    imgG = imgRGB[:, :, 1]
    imgB = imgRGB[:, :, 2]
    graymap_array = np.array(0.299 * imgR + 0.587 * imgG + 0.114 * imgB)
    from matplotlib.colors import hsv_to_rgb
    h = graymap_array
    s = np.ones_like(h)
    v = np.ones_like(h)
    rgb = hsv_to_rgb(np.moveaxis(np.array([h, s, v]), 0, -1))
    img_RGB = [Image.fromarray(np.round(255 * rgb[:, :, 0]).astype(np.uint8), 'L'), Image.fromarray(np.round(255 * rgb[:, :, 1]).astype(np.uint8), 'L'), Image.fromarray(np.round(255 * rgb[:, :, 2]).astype(np.uint8), 'L')]
    return Image.merge('RGB', img_RGB)
```
</details>
<!---Documatic-block-diffractsim.util.image_handling.convert_graymap_image_to_hsvmap_image-end--->
<!---Documatic-section-convert_graymap_image_to_hsvmap_image-end--->

# #
<!---Documatic-section-diffractsim.util.image_handling.convert_graymap_image_to_hsvmap_image-end--->

<!---Documatic-section-diffractsim.util.bluestein_FFT.bluestein_fft-start--->
## [diffractsim.util.bluestein_FFT.bluestein_fft](8-diffractsim_util.md#diffractsim.util.bluestein_FFT.bluestein_fft)

<!---Documatic-section-bluestein_fft-start--->
```mermaid
flowchart LR
diffractsim.util.bluestein_FFT.bluestein_fft-->diffractsim.util.chirp_z_transform.chirpz
```

### Object Calls

* diffractsim.util.chirp_z_transform.chirpz

<!---Documatic-block-diffractsim.util.bluestein_FFT.bluestein_fft-start--->
<details>
	<summary><code>diffractsim.util.bluestein_FFT.bluestein_fft</code> code snippet</summary>

```python
def bluestein_fft(x, axis, f0, f1, fs, M):
    global bd
    from .backend_functions import backend as bd
    x = bd.swapaxes(a=x, axis1=axis, axis2=-1)
    phi0 = 2.0 * bd.pi * f0 / fs
    phi1 = 2.0 * bd.pi * f1 / fs
    d_phi = (phi1 - phi0) / (M - 1)
    A = bd.exp(1j * phi0)
    W = bd.exp(-1j * d_phi)
    X = chirpz(x=x, A=A, W=W, M=M)
    return bd.swapaxes(a=X, axis1=axis, axis2=-1)
```
</details>
<!---Documatic-block-diffractsim.util.bluestein_FFT.bluestein_fft-end--->
<!---Documatic-section-bluestein_fft-end--->

# #
<!---Documatic-section-diffractsim.util.bluestein_FFT.bluestein_fft-end--->

[_Documentation generated by Documatic_](https://www.documatic.com)