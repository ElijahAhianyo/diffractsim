# Diffractsim Holography

[_Documentation generated by Documatic_](https://www.documatic.com)

<!---Documatic-section-Codebase Structure-start--->
## Codebase Structure

<!---Documatic-block-system_architecture-start--->
```mermaid
flowchart LR
holography-->util
```
<!---Documatic-block-system_architecture-end--->

# #
<!---Documatic-section-Codebase Structure-end--->

<!---Documatic-section-diffractsim.holography.fourier_phase_retrieval.FourierPhaseRetrieval-start--->
## [diffractsim.holography.fourier_phase_retrieval.FourierPhaseRetrieval](9-diffractsim_holography.md#diffractsim.holography.fourier_phase_retrieval.FourierPhaseRetrieval)

<!---Documatic-section-FourierPhaseRetrieval-start--->
<!---Documatic-block-diffractsim.holography.fourier_phase_retrieval.FourierPhaseRetrieval-start--->
<details>
	<summary><code>diffractsim.holography.fourier_phase_retrieval.FourierPhaseRetrieval</code> code snippet</summary>

```python
class FourierPhaseRetrieval:

    def __init__(self, target_amplitude_path, source_amplitude_path=None, new_size=None, pad=None):
        """class for retrieve the phase mask required to reconstruct an image (specified at target amplitude path) at the Fourier plane"""
        global bd
        from ..util.backend_functions import backend as bd
        self.target_amplitude = np.array(load_graymap_image_as_array(target_amplitude_path, new_size=new_size))
        if pad != None:
            self.target_amplitude = np.pad(self.target_amplitude, ((pad[1], pad[1]), (pad[0], pad[0])), 'constant')
        self.Nx = self.target_amplitude.shape[1]
        self.Ny = self.target_amplitude.shape[0]
        if source_amplitude_path != None:
            self.source_amplitude = np.array(load_graymap_image_as_array(source_amplitude_path, new_size=(self.Nx, self.Ny)))
        else:
            self.source_amplitude = np.ones((self.Ny, self.Nx))
        self.retrieved_phase = None

    def retrieve_phase_mask(self, max_iter=200, method='Conjugate-Gradient', CG_step=1.0, bluestein_zoom=1):
        implemented_methods = ('Gerchberg-Saxton', 'Conjugate-Gradient')
        bar = progressbar.ProgressBar()
        if method == 'Gerchberg-Saxton':
            target_amplitude = bd.array(resize_array(self.target_amplitude, (self.Ny + 2 * self.Ny // 2, self.Nx + 2 * self.Nx // 2)))
            source_amplitude = bd.pad(bd.array(self.source_amplitude), ((self.Ny // 2, self.Ny // 2), (self.Nx // 2, self.Nx // 2)), 'constant')
            target_amplitude = bd.abs(bd.fft.ifftshift(target_amplitude))
            source_amplitude = bd.abs(bd.fft.ifftshift(source_amplitude))
            g_p = bd.fft.ifft2(bd.fft.ifftshift(target_amplitude))
            for iter in bar(range(max_iter)):
                g = source_amplitude * bd.exp(1j * bd.angle(g_p))
                G = bd.fft.fft2(g)
                G_p = target_amplitude * bd.exp(1j * bd.angle(G))
                g_p = bd.fft.ifft2(G_p)
            self.retrieved_phase = bd.fft.fftshift(bd.angle(g_p))
            self.retrieved_phase = self.retrieved_phase[self.Ny // 2:-self.Ny // 2, self.Nx // 2:-self.Nx // 2]
        elif method == 'Conjugate-Gradient':
            target_amplitude = bd.array(resize_array(self.target_amplitude, (self.Ny + 2 * self.Ny // 2, self.Nx + 2 * self.Nx // 2)))
            source_amplitude = bd.pad(bd.array(self.source_amplitude), ((self.Ny // 2, self.Ny // 2), (self.Nx // 2, self.Nx // 2)), 'constant')
            target_amplitude = bd.abs(bd.fft.ifftshift(target_amplitude))
            source_amplitude = bd.abs(bd.fft.ifftshift(source_amplitude))
            g_pp = bd.fft.ifft2(bd.fft.ifftshift(target_amplitude))
            g = bd.abs(source_amplitude) * bd.exp(1j * bd.angle(g_pp))
            gp_last_iter = g
            bar = progressbar.ProgressBar()
            for iter in bar(range(max_iter)):
                G = bd.fft.fft2(g)
                G_p = target_amplitude * bd.exp(1j * bd.angle(G))
                g_p = bd.fft.ifft2(G_p)
                g_pp = g_p + CG_step * (g_p - gp_last_iter)
                '\n                Note: \n\n                The line before (g_pp = g_p + CG_step * (g_p - gp_last_iter)\n                can be replaced to the following more common form of the Conjugate-Gradient method, where B is the gradient: \n                (See the above Fineup article)\n\n                B = squared_err # (B is the objective function to minimize)\n                D = (g_p - g) + (B / B_last_iter) * D_last_iter\n                \n                where D in the first iteration is D = g_p - g\n\n                g_pp = g + CG_step * D\n                '
                g_pp = bd.abs(source_amplitude) * bd.exp(1j * np.angle(g_pp))
                gp_last_iter = g_p
                g = g_pp
            self.retrieved_phase = bd.fft.fftshift(bd.angle(g_pp))
            self.retrieved_phase = self.retrieved_phase[self.Ny // 2:-self.Ny // 2, self.Nx // 2:-self.Nx // 2]
        else:
            raise NotImplementedError(f'{method} has not been implemented. Use one of {implemented_methods}')

    def save_retrieved_phase_as_image(self, name, phase_mask_format='hsv'):
        if bd == np:
            save_phase_mask_as_image(name, self.retrieved_phase, phase_mask_format=phase_mask_format)
        else:
            save_phase_mask_as_image(name, self.retrieved_phase.get(), phase_mask_format=phase_mask_format)

    def set_source_amplitude_from_function(self, function, extent_x, extent_y):
        x = extent_x * (bd.arange(self.Nx) - self.Nx // 2) / self.Nx
        y = extent_y * (bd.arange(self.Ny) - self.Ny // 2) / self.Ny
        (xx, yy) = bd.meshgrid(x, y)
        self.source_amplitude = function(xx, yy)
```
</details>
<!---Documatic-block-diffractsim.holography.fourier_phase_retrieval.FourierPhaseRetrieval-end--->
<!---Documatic-section-FourierPhaseRetrieval-end--->

# #
<!---Documatic-section-diffractsim.holography.fourier_phase_retrieval.FourierPhaseRetrieval-end--->

<!---Documatic-section-diffractsim.holography.custom_phase_retrieval.CustomPhaseRetrieval-start--->
## [diffractsim.holography.custom_phase_retrieval.CustomPhaseRetrieval](9-diffractsim_holography.md#diffractsim.holography.custom_phase_retrieval.CustomPhaseRetrieval)

<!---Documatic-section-CustomPhaseRetrieval-start--->
<!---Documatic-block-diffractsim.holography.custom_phase_retrieval.CustomPhaseRetrieval-start--->
<details>
	<summary><code>diffractsim.holography.custom_phase_retrieval.CustomPhaseRetrieval</code> code snippet</summary>

```python
class CustomPhaseRetrieval:

    def __init__(self, wavelength, z, extent_x, extent_y, Nx, Ny):
        """class for retrieve the phase mask required to reconstruct an image (specified at target amplitude path) at a distance z"""
        global bd
        from ..util.backend_functions import backend as bd
        self.extent_x = extent_x
        self.extent_y = extent_y
        self.z = z
        self.dx = self.extent_x / Nx
        self.dy = self.extent_y / Ny
        self.x = self.dx * (bd.arange(Nx) - Nx // 2)
        self.y = self.dy * (bd.arange(Ny) - Ny // 2)
        (self.xx, self.yy) = bd.meshgrid(self.x, self.y)
        self.Nx = Nx
        self.Ny = Ny
        self.λ = wavelength

    def set_source_amplitude(self, amplitude_mask_path, image_size=None):
        img = Image.open(Path(amplitude_mask_path))
        img = img.convert('RGB')
        rescaled_img = rescale_img_to_custom_coordinates(img, image_size, self.extent_x, self.extent_y, self.Nx, self.Ny)
        imgRGB = np.asarray(rescaled_img) / 255.0
        t = 0.299 * imgRGB[:, :, 0] + 0.587 * imgRGB[:, :, 1] + 0.114 * imgRGB[:, :, 2]
        t = bd.array(np.flip(t, axis=0))
        self.source_amplitude = t
        self.source_size = image_size

    def set_target_amplitude(self, amplitude_mask_path, image_size=None):
        img = Image.open(Path(amplitude_mask_path))
        img = img.convert('RGB')
        rescaled_img = rescale_img_to_custom_coordinates(img, image_size, self.extent_x, self.extent_y, self.Nx, self.Ny)
        imgRGB = np.asarray(rescaled_img) / 255.0
        t = 0.299 * imgRGB[:, :, 0] + 0.587 * imgRGB[:, :, 1] + 0.114 * imgRGB[:, :, 2]
        t = bd.array(np.flip(t, axis=0))
        self.target_amplitude = t

    def retrieve_phase_mask(self, max_iter=20, method='Adam-Optimizer', propagation_method='Angular-Spectrum', learning_rate=1.0):
        implemented_phase_retrieval_methods = ('Conjugate-Gradient', 'Stochastic-Gradient-Descent', 'Adam-Optimizer')
        implemented_propagation_methods = ('Angular-Spectrum', 'Fresnel')
        import autograd.numpy as npa
        from autograd import elementwise_grad as egrad
        if propagation_method == 'Angular-Spectrum':
            fx = npa.fft.fftshift(npa.fft.fftfreq(self.Nx, d=self.dx))
            fy = npa.fft.fftshift(npa.fft.fftfreq(self.Ny, d=self.dy))
            (fxx, fyy) = np.meshgrid(fx, fy)

            def objective_function(phase):
                phase = phase.reshape(self.Ny, self.Nx)
                c = npa.fft.fftshift(npa.fft.fft2(self.source_amplitude * npa.exp(1j * phase)))
                argument = (2 * npa.pi) ** 2 * ((1.0 / self.λ) ** 2 - fxx ** 2 - fyy ** 2)
                tmp = npa.sqrt(npa.abs(argument))
                kz = npa.where(argument >= 0, tmp, 1j * tmp)
                E = npa.abs(npa.fft.ifft2(npa.fft.ifftshift(c * npa.exp(1j * kz * self.z))))
                return npa.sum((self.target_amplitude - E) ** 2)
            self.grad_F = egrad(objective_function)

            def masked_objective_function(phase, mask):
                phase = phase.reshape(self.Ny, self.Nx)
                c = npa.fft.fftshift(npa.fft.fft2(self.source_amplitude * npa.exp(1j * phase)))
                argument = (2 * npa.pi) ** 2 * ((1.0 / self.λ) ** 2 - fxx ** 2 - fyy ** 2)
                tmp = npa.sqrt(npa.abs(argument))
                kz = npa.where(argument >= 0, tmp, 1j * tmp)
                E = npa.abs(npa.fft.ifft2(npa.fft.ifftshift(c * npa.exp(1j * kz * self.z))))
                f = (self.target_amplitude - E)[mask]
                return npa.sum(f ** 2)
            self.grad_F_masked = egrad(masked_objective_function)
        elif propagation_method == 'Fresnel':

            def objective_function(phase):
                phase = phase.reshape(self.Ny, self.Nx)
                E = npa.abs(npa.fft.fftshift(npa.fft.fft2(self.source_amplitude * npa.exp(1j * 2 * np.pi / self.λ / (2 * self.z) * (self.xx ** 2 + self.yy ** 2)) * npa.exp(1j * phase))))
                return npa.sum((self.target_amplitude - E) ** 2)
            self.grad_F = egrad(objective_function)

            def masked_objective_function(phase, mask):
                phase = phase.reshape(self.Ny, self.Nx)
                E = npa.abs(npa.fft.fftshift(npa.fft.fft2(self.source_amplitude * npa.exp(1j * 2 * np.pi / self.λ / (2 * self.z) * (self.xx ** 2 + self.yy ** 2)) * npa.exp(1j * phase))))
                f = (self.target_amplitude - E)[mask]
                return npa.sum(f ** 2)
            self.grad_F_masked = egrad(masked_objective_function)
        else:
            raise NotImplementedError(f'{method} has not been implemented. Use one of {implemented_propagation_methods}')
        if method == 'Conjugate-Gradient':
            '\n            Nonlinear conjugate gradient algorithm by Polak and Ribiere\n\n            Reference: \n            Nocedal, J, and S J Wright. 2006. Numerical Optimization. Springer New York.\n            https://docs.scipy.org/doc/scipy/reference/optimize.minimize-cg.html#optimize-minimize-cg\n            '
            import scipy
            from scipy.optimize import minimize
            intial_phase = np.array(np.angle(np.fft.ifft2(np.fft.ifftshift(self.target_amplitude))))
            result = scipy.optimize.minimize(objective_function, intial_phase, method='CG', jac=self.grad_F, tol=1e-08, options={'maxiter': max_iter})
            retrieved_phase = result.x.reshape(self.Ny, self.Nx)
            self.retrieved_phase = np.where(retrieved_phase < 0, retrieved_phase + np.floor(np.min(retrieved_phase) / (2 * np.pi)) * 2 * np.pi, retrieved_phase)
            self.retrieved_phase = self.retrieved_phase % (2 * np.pi) - np.pi
        elif method == 'Stochastic-Gradient-Descent':
            '\n            Two batch stochastic gradient descent with momentum.\n            '
            mass = 0.9
            from scipy.optimize import OptimizeResult
            intial_phase = np.array(np.angle(np.fft.ifft2(np.fft.ifftshift(self.target_amplitude))))
            x = intial_phase
            velocity = np.zeros_like(x)
            bar = progressbar.ProgressBar()
            for i in bar(range(max_iter)):
                mask = np.random.randint(0, 2, x.shape, dtype=bool)
                g = self.grad_F_masked(x, mask)
                velocity = mass * velocity - (1.0 - mass) * g
                x = x + learning_rate * velocity
                g = self.grad_F_masked(x, ~mask)
                velocity = mass * velocity - (1.0 - mass) * g
                x = x + learning_rate * velocity
            i += 1
            result = OptimizeResult(x=x, fun=objective_function(x), jac=g, nit=i, nfev=i, success=True)
            retrieved_phase = result.x.reshape(self.Ny, self.Nx)
            self.retrieved_phase = np.where(retrieved_phase < 0, retrieved_phase + np.floor(np.min(retrieved_phase) / (2 * np.pi)) * 2 * np.pi, retrieved_phase)
            self.retrieved_phase = self.retrieved_phase % (2 * np.pi) - np.pi
        elif method == 'Adam-Optimizer':
            '\n            Reference: \n            Adam: A Method for Stochastic Optimization\n            http://arxiv.org/pdf/1412.6980.pdf.\n            '
            beta1 = 0.9
            beta2 = 0.999
            eps = 1e-08
            from scipy.optimize import OptimizeResult
            intial_phase = np.array(np.angle(np.fft.ifft2(np.fft.ifftshift(self.target_amplitude))))
            x = intial_phase
            m = np.zeros_like(x)
            v = np.zeros_like(x)
            bar = progressbar.ProgressBar()
            for i in bar(range(max_iter)):
                mask = np.random.randint(0, 2, x.shape)
                g = self.grad_F(x)
                m = (1 - beta1) * g + beta1 * m
                v = (1 - beta2) * g ** 2 + beta2 * v
                mhat = m / (1 - beta1 ** (i + 1))
                vhat = v / (1 - beta2 ** (i + 1))
                x = x - learning_rate * mhat / (np.sqrt(vhat) + eps)
            i += 1
            result = OptimizeResult(x=x, fun=objective_function(x), jac=g, nit=i, nfev=i, success=True)
            retrieved_phase = result.x.reshape(self.Ny, self.Nx)
            self.retrieved_phase = np.where(retrieved_phase < 0, retrieved_phase + np.floor(np.min(retrieved_phase) / (2 * np.pi)) * 2 * np.pi, retrieved_phase)
            self.retrieved_phase = self.retrieved_phase % (2 * np.pi) - np.pi
        else:
            raise NotImplementedError(f'{method} has not been implemented. Use one of {implemented_phase_retrieval_methods}')

    def save_retrieved_phase_as_image(self, name, phase_mask_format='hsv'):
        if bd == np:
            save_phase_mask_as_image(name, self.retrieved_phase, phase_mask_format=phase_mask_format)
        else:
            save_phase_mask_as_image(name, self.retrieved_phase.get(), phase_mask_format=phase_mask_format)
```
</details>
<!---Documatic-block-diffractsim.holography.custom_phase_retrieval.CustomPhaseRetrieval-end--->
<!---Documatic-section-CustomPhaseRetrieval-end--->

# #
<!---Documatic-section-diffractsim.holography.custom_phase_retrieval.CustomPhaseRetrieval-end--->

[_Documentation generated by Documatic_](https://www.documatic.com)